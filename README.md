# CAUCS_2020_Algorithm
This is the assignment ouptut of Chung-Ang(Seoul, Korea) university Computer Science Algorithm class year of 2020.

The assignment is about explaining various kinds of algorithm given by professor.

Following algorithms are included in this document.

In this readme document only explanation about each algorithm is included. The real code can be found in folder named after the algorithm. 

The explanation is written in both korean and english.

### Divide and Concquer Algorithms

분할 정복 방법, 분할 정복 알고리즘은 큰 문제를 작은 것들로 쪼개면서 해결해나가는 방법이다. 

#### Binary Search 

한국어로는 이진 탐색이라고 불리운다. 복잡도는 O(log N)이다. 이를 적용하기 위해서는 요소들이 오름차순으로 정렬이 된 배열이 있어야 한다는 단점이 있다. 이진 탐색은 배열에서 특정 요소를 찾으려는 상황에서 유용하게 사용된다. 

탐색 방법은 찾으려는 요소를 지속적으로 배열의 가운데 요소와 비교하는 것이다. 만약 찾으려는 요소가 가운데의 요소보다 크다면 가운데 요소 뒤(오른쪽에 위치한)의 요소들을 하나의 배열로 인식하여 다시 가운데 요소와 크기를 비교한다. 작다면, 가운데 요소 앞(왼쪽에 위치한)의 요소들을 하나의 배열로 인식하여 다시 가운데 요소와 크기를 비교한다. 

반복하여 찾을 때까지 반복한다.

예를 들어, {1,2,3,4,5,6,10,15}라는 배열이 있고 여기서 3을 찾는 상황이다. 처음으로 하는 행위는 배열의 가운데에 위치한 5(작성하는 사람에 따라 4로 행할 수도 있다.)와 3을 비교한다. 5는 3보다 크기 때문에 5라는 요소의 앞(왼쪽에 위치한)에 있는 요소들을 하나의 배열로 인식한다. 

즉, 이 상황에서는 {1,2,3,4}가 하나의 배열이 되고 다시 이 배열의 가운데 값과 찾으려는 값을 비교한다. 새로운 배열의 가운데는 3이고, 찾으려는 값 역시 3이다. 

찾고자 하는 값을 찾았으니, 이 요소의 인덱스 값을 반환한다.

#### Merge sort

그대로 읽어 머지소트라고도 하지만 한국어로 합병정렬, 병합정렬이라고도 불리운다. 복잡도는 O(nlogn)이다. 주어진 배열의 길이가 1이 될 때까지 반으로 나눈다. 모두 나눠지고 나면, 정렬하면서 데이터를 다시 합친다.(merge) 결과물은 오름차순으로 정리된 배열이 나오게 된다. 

예를 들어, {6,5,3,4,1,7,8,2}이라는 배열이 있다. 이를 먼저 2개로 지속적으로 나누어 길이가 1이 될 때까지 반복한다. 위의 배열을 나눈다면 {6,5,3,4} 그리고 {1,7,8,2}로 나누어진다. 이는 다시 {6,5}, {3,4}, {1,7}, {8,2}로 나누어지며 이는 다시 각각 {6}, {5}, {3}, {4}, {1}, {7}, {8}, {2}로 나누어진다. 나누기가 완료되었으면, 이제 다시 합치기를 진행한다. 합칠 때 결과물이 오름차순으로 정렬되게 크기를 비교하여 합친다. 

{6,5}가 아닌 {5,6}으로 {3,4}, {1,7} 그리고 {2,8}로 합쳐진다. 이는 다시 {3,4,5,6} 그리고 {1,2,7,8}로 합쳐지고 결과적으로 {1,2,3,4,5,6,7,8}으로 합쳐진다. 

오름차순으로 정렬된 배열을 결과물로 받았다.

#### Quick sort 

보통 그대로 읽어 퀵소트라고 불리우며 가끔 퀵정렬이라고도 불리운다. 복잡도는 O(nlogn)이다. 퀵소트에서는 pivot과 L,R이 등장한다. 어느 값을 정해도 상관없지만, 효율성을 위해서 가운데 숫자를 pivot을 선택하는 경우가 많다. 퀵소트에는 pivot은 

(추가적으로 진행해야함)

### Dynamic Programming

#### Fibonacci Numbers

피보차니 수열은 0과 1을 각각 제 0항과 제 1항으로 두며, 그 뒤의 모든 항들은 각 항의 바로 앞 2개의 항의 합인 수열이다. 즉 제 0항과 1항을 제외한 나머지 항들은 an = an-1 + an-2 을 점화식으로 둔 수열이다. 피보나치 수열을 표현해낼 수 있는 방법은 여러가지가 존재한다. 

#### Binomial Coefficient

한국어로 이항계수라고 불리운다. 한국 교과과정에서는 주로 콤비네이션(combination)으로 소개되었을 것이다. 주어진 크기에서 순서없이 뽑을 수 있는 조합의 가짓수를 의미한다. 예를 들어, 서로 다른 5개 중 2개를 뽑는 경우라면 10가지 경우의 수가 나오게 된다. 

2가지 종류의 수가 필요하다. 전체 선택지, 위에서는 5 그리고 뽑는 수, 위에서는 2이다. 이 역시 구현할 수 있는 방법은 여러가지가 있다. 층으로 나누어 1씩 숫자를 줄여나가는 형태로 구현해갈 것이다. 

예를 들어, 위의 경우에는 (5,2)가 된다. 밑에 층에는 왼쪽에는 (4,1)이 오른쪽에는 (4,2)가 위치하게 된다. 왼쪽의 (4,1)은 다시 (3,0) 그리고 (3,1)이 아래에 위치하게 된다. 뒤의 숫자가 0이 되거나 (1,1)의 결과가 나올 때까지 지속적으로 밑에까지 내려간다. 내려간 후에 숫자 쌍의 개수를 세고 그 결과를 반환한다.

#### Floyd Warshall Algorithm

플로이드-워셜 알고리즘은 그래프에 있는 모든 점들 사이의 최단 거리를 구하는 알고리즘이다. 시간 복잡도는 O(V^3)이다. 그래프에 음의 가중치가 존재해도 잘 작동한다. 그래프에는 노드와 엣지가 등장한다. 노드는 주로 원의 형태로 위치를 의미하고 엣지는 줄의 형태로 가중치와 함께 표현된다. 그리고 이는 행렬로 표현된다. 

행렬을 기준으로 하여 그 경로가 지날 때마다 가중치를 합하고 최소가 되는 경로를 찾는다. 알고리즘 자체는 경로를 반환하지는 않지만, 약간의 수정을 가하면 경로도 반환할 수 있다. 

#### Matrix Chain Multiplication

주로 한국어로는 연쇄 행렬 곱셈으로 불리운다. 

(추가적으로 진행해야함)

### Greedy Algorithms

#### Prim’s Minimum Spanning Tree Algorithm

#### Kruskal’s Minimum Spanning Tree Algorithm

#### Dijkstra’s Shortest Path Algorithm

### Reference 

Most of explanatoion and code referenced from geeksforgeeks site.